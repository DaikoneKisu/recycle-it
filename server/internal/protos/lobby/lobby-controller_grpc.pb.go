// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.19.6
// source: lobby/lobby-controller.proto

package lobby

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LobbyController_CreateLobby_FullMethodName  = "/lobby.LobbyController/CreateLobby"
	LobbyController_JoinLobby_FullMethodName    = "/lobby.LobbyController/JoinLobby"
	LobbyController_LeaveMyLobby_FullMethodName = "/lobby.LobbyController/LeaveMyLobby"
	LobbyController_GetLobbies_FullMethodName   = "/lobby.LobbyController/GetLobbies"
	LobbyController_CloseMyLobby_FullMethodName = "/lobby.LobbyController/CloseMyLobby"
)

// LobbyControllerClient is the client API for LobbyController service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LobbyControllerClient interface {
	CreateLobby(ctx context.Context, in *CreateLobbyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CreateLobbyResponse], error)
	JoinLobby(ctx context.Context, in *JoinLobbyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JoinLobbyResponse], error)
	LeaveMyLobby(ctx context.Context, in *LeaveMyLobbyRequest, opts ...grpc.CallOption) (*LeaveMyLobbyResponse, error)
	GetLobbies(ctx context.Context, in *GetLobbiesRequest, opts ...grpc.CallOption) (*GetLobbiesResponse, error)
	CloseMyLobby(ctx context.Context, in *CloseLobbyRequest, opts ...grpc.CallOption) (*CloseLobbyResponse, error)
}

type lobbyControllerClient struct {
	cc grpc.ClientConnInterface
}

func NewLobbyControllerClient(cc grpc.ClientConnInterface) LobbyControllerClient {
	return &lobbyControllerClient{cc}
}

func (c *lobbyControllerClient) CreateLobby(ctx context.Context, in *CreateLobbyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[CreateLobbyResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LobbyController_ServiceDesc.Streams[0], LobbyController_CreateLobby_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[CreateLobbyRequest, CreateLobbyResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyController_CreateLobbyClient = grpc.ServerStreamingClient[CreateLobbyResponse]

func (c *lobbyControllerClient) JoinLobby(ctx context.Context, in *JoinLobbyRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[JoinLobbyResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LobbyController_ServiceDesc.Streams[1], LobbyController_JoinLobby_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[JoinLobbyRequest, JoinLobbyResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyController_JoinLobbyClient = grpc.ServerStreamingClient[JoinLobbyResponse]

func (c *lobbyControllerClient) LeaveMyLobby(ctx context.Context, in *LeaveMyLobbyRequest, opts ...grpc.CallOption) (*LeaveMyLobbyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveMyLobbyResponse)
	err := c.cc.Invoke(ctx, LobbyController_LeaveMyLobby_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyControllerClient) GetLobbies(ctx context.Context, in *GetLobbiesRequest, opts ...grpc.CallOption) (*GetLobbiesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLobbiesResponse)
	err := c.cc.Invoke(ctx, LobbyController_GetLobbies_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lobbyControllerClient) CloseMyLobby(ctx context.Context, in *CloseLobbyRequest, opts ...grpc.CallOption) (*CloseLobbyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CloseLobbyResponse)
	err := c.cc.Invoke(ctx, LobbyController_CloseMyLobby_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LobbyControllerServer is the server API for LobbyController service.
// All implementations must embed UnimplementedLobbyControllerServer
// for forward compatibility.
type LobbyControllerServer interface {
	CreateLobby(*CreateLobbyRequest, grpc.ServerStreamingServer[CreateLobbyResponse]) error
	JoinLobby(*JoinLobbyRequest, grpc.ServerStreamingServer[JoinLobbyResponse]) error
	LeaveMyLobby(context.Context, *LeaveMyLobbyRequest) (*LeaveMyLobbyResponse, error)
	GetLobbies(context.Context, *GetLobbiesRequest) (*GetLobbiesResponse, error)
	CloseMyLobby(context.Context, *CloseLobbyRequest) (*CloseLobbyResponse, error)
	mustEmbedUnimplementedLobbyControllerServer()
}

// UnimplementedLobbyControllerServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLobbyControllerServer struct{}

func (UnimplementedLobbyControllerServer) CreateLobby(*CreateLobbyRequest, grpc.ServerStreamingServer[CreateLobbyResponse]) error {
	return status.Errorf(codes.Unimplemented, "method CreateLobby not implemented")
}
func (UnimplementedLobbyControllerServer) JoinLobby(*JoinLobbyRequest, grpc.ServerStreamingServer[JoinLobbyResponse]) error {
	return status.Errorf(codes.Unimplemented, "method JoinLobby not implemented")
}
func (UnimplementedLobbyControllerServer) LeaveMyLobby(context.Context, *LeaveMyLobbyRequest) (*LeaveMyLobbyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveMyLobby not implemented")
}
func (UnimplementedLobbyControllerServer) GetLobbies(context.Context, *GetLobbiesRequest) (*GetLobbiesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLobbies not implemented")
}
func (UnimplementedLobbyControllerServer) CloseMyLobby(context.Context, *CloseLobbyRequest) (*CloseLobbyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseMyLobby not implemented")
}
func (UnimplementedLobbyControllerServer) mustEmbedUnimplementedLobbyControllerServer() {}
func (UnimplementedLobbyControllerServer) testEmbeddedByValue()                         {}

// UnsafeLobbyControllerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LobbyControllerServer will
// result in compilation errors.
type UnsafeLobbyControllerServer interface {
	mustEmbedUnimplementedLobbyControllerServer()
}

func RegisterLobbyControllerServer(s grpc.ServiceRegistrar, srv LobbyControllerServer) {
	// If the following call pancis, it indicates UnimplementedLobbyControllerServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LobbyController_ServiceDesc, srv)
}

func _LobbyController_CreateLobby_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(CreateLobbyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LobbyControllerServer).CreateLobby(m, &grpc.GenericServerStream[CreateLobbyRequest, CreateLobbyResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyController_CreateLobbyServer = grpc.ServerStreamingServer[CreateLobbyResponse]

func _LobbyController_JoinLobby_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JoinLobbyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LobbyControllerServer).JoinLobby(m, &grpc.GenericServerStream[JoinLobbyRequest, JoinLobbyResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LobbyController_JoinLobbyServer = grpc.ServerStreamingServer[JoinLobbyResponse]

func _LobbyController_LeaveMyLobby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveMyLobbyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyControllerServer).LeaveMyLobby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyController_LeaveMyLobby_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyControllerServer).LeaveMyLobby(ctx, req.(*LeaveMyLobbyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyController_GetLobbies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLobbiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyControllerServer).GetLobbies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyController_GetLobbies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyControllerServer).GetLobbies(ctx, req.(*GetLobbiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LobbyController_CloseMyLobby_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseLobbyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LobbyControllerServer).CloseMyLobby(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LobbyController_CloseMyLobby_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LobbyControllerServer).CloseMyLobby(ctx, req.(*CloseLobbyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LobbyController_ServiceDesc is the grpc.ServiceDesc for LobbyController service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LobbyController_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "lobby.LobbyController",
	HandlerType: (*LobbyControllerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LeaveMyLobby",
			Handler:    _LobbyController_LeaveMyLobby_Handler,
		},
		{
			MethodName: "GetLobbies",
			Handler:    _LobbyController_GetLobbies_Handler,
		},
		{
			MethodName: "CloseMyLobby",
			Handler:    _LobbyController_CloseMyLobby_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CreateLobby",
			Handler:       _LobbyController_CreateLobby_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "JoinLobby",
			Handler:       _LobbyController_JoinLobby_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "lobby/lobby-controller.proto",
}
